[
  {
    "objectID": "02-wrangling/03-tables.html",
    "href": "02-wrangling/03-tables.html",
    "title": "Better tables with {gt}",
    "section": "",
    "text": "This short tutorial shows common gt workflows: build a basic table, format numbers and labels, add color scales, and produce a grouped summary.",
    "crumbs": [
      "Data Manipulation",
      "Better tables with {gt}"
    ]
  },
  {
    "objectID": "02-wrangling/03-tables.html#quick-tutorial-gt-with-the-palmerpenguins-dataset",
    "href": "02-wrangling/03-tables.html#quick-tutorial-gt-with-the-palmerpenguins-dataset",
    "title": "Better tables with {gt}",
    "section": "",
    "text": "This short tutorial shows common gt workflows: build a basic table, format numbers and labels, add color scales, and produce a grouped summary.",
    "crumbs": [
      "Data Manipulation",
      "Better tables with {gt}"
    ]
  },
  {
    "objectID": "02-wrangling/03-tables.html#setup",
    "href": "02-wrangling/03-tables.html#setup",
    "title": "Better tables with {gt}",
    "section": "Setup",
    "text": "Setup\nInstall and load packages (only once):\n\n# install.packages(c(\"gt\", \"palmerpenguins\", \"dplyr\", \"scales\"))\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(gt)\nlibrary(palmerpenguins)\n\n\nAttaching package: 'palmerpenguins'\n\nThe following objects are masked from 'package:datasets':\n\n    penguins, penguins_raw\n\nlibrary(scales)\n\n\nAttaching package: 'scales'\n\nThe following object is masked from 'package:purrr':\n\n    discard\n\nThe following object is masked from 'package:readr':\n\n    col_factor\n\n\n\nBasic table Select a handful of columns and render a simple gt table.\n\n\npenguins_clean &lt;- penguins %&gt;%\n  select(species, island, bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g, sex) %&gt;%\n  drop_na()\n\npenguins_clean %&gt;%\n  slice_head(n = 10) %&gt;%\n  gt()\n\n\n\n\n\n\n\nspecies\nisland\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\nsex\n\n\n\n\nAdelie\nTorgersen\n39.1\n18.7\n181\n3750\nmale\n\n\nAdelie\nTorgersen\n39.5\n17.4\n186\n3800\nfemale\n\n\nAdelie\nTorgersen\n40.3\n18.0\n195\n3250\nfemale\n\n\nAdelie\nTorgersen\n36.7\n19.3\n193\n3450\nfemale\n\n\nAdelie\nTorgersen\n39.3\n20.6\n190\n3650\nmale\n\n\nAdelie\nTorgersen\n38.9\n17.8\n181\n3625\nfemale\n\n\nAdelie\nTorgersen\n39.2\n19.6\n195\n4675\nmale\n\n\nAdelie\nTorgersen\n41.1\n17.6\n182\n3200\nfemale\n\n\nAdelie\nTorgersen\n38.6\n21.2\n191\n3800\nmale\n\n\nAdelie\nTorgersen\n34.6\n21.1\n198\n4400\nmale\n\n\n\n\n\n\n\n\nFormat numbers and labels Use gt formatting helpers to control decimal places and column labels.\n\n\npenguins_clean %&gt;%\n  slice_head(n = 10) %&gt;%\n  gt() %&gt;%\n  cols_label(\n    species = \"Species\",\n    island = \"Island\",\n    bill_length_mm = \"Bill (mm)\",\n    bill_depth_mm  = \"Bill depth (mm)\",\n    flipper_length_mm = \"Flipper (mm)\",\n    body_mass_g = \"Body mass (g)\",\n    sex = \"Sex\"\n  ) %&gt;%\n  fmt_number(\n    columns = c(\"bill_length_mm\", \"bill_depth_mm\", \"flipper_length_mm\"),\n    decimals = 1\n  ) %&gt;%\n  fmt_number(\n    columns = c(\"body_mass_g\"),\n    decimals = 0\n  )\n\n\n\n\n\n\n\nSpecies\nIsland\nBill (mm)\nBill depth (mm)\nFlipper (mm)\nBody mass (g)\nSex\n\n\n\n\nAdelie\nTorgersen\n39.1\n18.7\n181.0\n3,750\nmale\n\n\nAdelie\nTorgersen\n39.5\n17.4\n186.0\n3,800\nfemale\n\n\nAdelie\nTorgersen\n40.3\n18.0\n195.0\n3,250\nfemale\n\n\nAdelie\nTorgersen\n36.7\n19.3\n193.0\n3,450\nfemale\n\n\nAdelie\nTorgersen\n39.3\n20.6\n190.0\n3,650\nmale\n\n\nAdelie\nTorgersen\n38.9\n17.8\n181.0\n3,625\nfemale\n\n\nAdelie\nTorgersen\n39.2\n19.6\n195.0\n4,675\nmale\n\n\nAdelie\nTorgersen\n41.1\n17.6\n182.0\n3,200\nfemale\n\n\nAdelie\nTorgersen\n38.6\n21.2\n191.0\n3,800\nmale\n\n\nAdelie\nTorgersen\n34.6\n21.1\n198.0\n4,400\nmale\n\n\n\n\n\n\n\n\nAdd a color scale Highlight body mass with a color ramp to make patterns visible.\n\n\nbody_range &lt;- range(penguins_clean$body_mass_g, na.rm = TRUE)\n\npenguins_clean %&gt;%\n  slice_head(n = 10) %&gt;%\n  gt() %&gt;%\n  cols_label(body_mass_g = \"Body mass (g)\") %&gt;%\n  data_color(\n    columns = c(\"body_mass_g\"),\n    colors = col_numeric(\n      palette = c(\"lightyellow\", \"orange\", \"red\"),\n      domain = body_range\n    )\n  ) %&gt;%\n  fmt_number(columns = vars(body_mass_g), decimals = 0)\n\nWarning: Since gt v0.9.0, the `colors` argument has been deprecated.\n• Please use the `fn` argument instead.\nThis warning is displayed once every 8 hours.\n\n\nWarning: Since gt v0.3.0, `columns = vars(...)` has been deprecated.\n• Please use `columns = c(...)` instead.\n\n\n\n\n\n\n\n\nspecies\nisland\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nBody mass (g)\nsex\n\n\n\n\nAdelie\nTorgersen\n39.1\n18.7\n181\n3,750\nmale\n\n\nAdelie\nTorgersen\n39.5\n17.4\n186\n3,800\nfemale\n\n\nAdelie\nTorgersen\n40.3\n18.0\n195\n3,250\nfemale\n\n\nAdelie\nTorgersen\n36.7\n19.3\n193\n3,450\nfemale\n\n\nAdelie\nTorgersen\n39.3\n20.6\n190\n3,650\nmale\n\n\nAdelie\nTorgersen\n38.9\n17.8\n181\n3,625\nfemale\n\n\nAdelie\nTorgersen\n39.2\n19.6\n195\n4,675\nmale\n\n\nAdelie\nTorgersen\n41.1\n17.6\n182\n3,200\nfemale\n\n\nAdelie\nTorgersen\n38.6\n21.2\n191\n3,800\nmale\n\n\nAdelie\nTorgersen\n34.6\n21.1\n198\n4,400\nmale\n\n\n\n\n\n\n\nUsing scales to create the colour mapper The function col_numeric() used above comes from the scales package (scales::col_numeric). It builds and returns a function that maps numeric values to colors; you pass that function to gt::data_color so gt can colour cells based on the numeric values. The two important arguments are palette (the colour stops — use hex codes or a perceptually uniform palette like viridis) and domain (the numeric range to map).\nTip: construct the mapping function explicitly so you can inspect or reuse it, and prefer explicit domains (range(…, na.rm = TRUE)) and hex colours for reproducibility and accessibility.\n\n# create a reusable colour-mapping function (example using viridis)\nlibrary(viridisLite)   # lightweight dependency for perceptual colours\n\ncolor_fn &lt;- scales::col_numeric(\n  palette = viridisLite::viridis(5),                       # perceptually uniform palette\n  domain  = range(penguins_clean$body_mass_g, na.rm = TRUE) # explicit numeric domain\n)\n\n# inspect output for a few values\ncolor_fn(c(2700, 3500, 5000))\n\n[1] \"#440154\" \"#3E4B85\" \"#4BAF77\"\n\n# use the function with gt::data_color\npenguins_clean %&gt;%\n  slice_head(n = 10) %&gt;%\n  gt() %&gt;%\n  cols_label(body_mass_g = \"Body mass (g)\") %&gt;%\n  data_color(columns = c(\"body_mass_g\"), colors = color_fn) %&gt;%\n  fmt_number(columns = vars(body_mass_g), decimals = 0)\n\nWarning: Since gt v0.3.0, `columns = vars(...)` has been deprecated.\n• Please use `columns = c(...)` instead.\n\n\n\n\n\n\n\n\nspecies\nisland\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nBody mass (g)\nsex\n\n\n\n\nAdelie\nTorgersen\n39.1\n18.7\n181\n3,750\nmale\n\n\nAdelie\nTorgersen\n39.5\n17.4\n186\n3,800\nfemale\n\n\nAdelie\nTorgersen\n40.3\n18.0\n195\n3,250\nfemale\n\n\nAdelie\nTorgersen\n36.7\n19.3\n193\n3,450\nfemale\n\n\nAdelie\nTorgersen\n39.3\n20.6\n190\n3,650\nmale\n\n\nAdelie\nTorgersen\n38.9\n17.8\n181\n3,625\nfemale\n\n\nAdelie\nTorgersen\n39.2\n19.6\n195\n4,675\nmale\n\n\nAdelie\nTorgersen\n41.1\n17.6\n182\n3,200\nfemale\n\n\nAdelie\nTorgersen\n38.6\n21.2\n191\n3,800\nmale\n\n\nAdelie\nTorgersen\n34.6\n21.1\n198\n4,400\nmale\n\n\n\n\n\n\n\nFor other needs, scales also provides helpers like col_bin(), col_quantile(), and col_factor() to create binned, quantile-based, or categorical colour mappings. ``````\n\nGrouped summary (per species) Create a summary table grouped by species: mean body mass and median flipper length.\n\n\nsummary_tbl &lt;- penguins_clean %&gt;%\n  group_by(species) %&gt;%\n  summarise(\n    n = n(),\n    mean_body_mass = mean(body_mass_g, na.rm = TRUE),\n    median_flipper = median(flipper_length_mm, na.rm = TRUE)\n  ) %&gt;%\n  ungroup()\n\nsummary_tbl %&gt;%\n  gt(rowname_col = \"species\") %&gt;%\n  cols_label(\n    n = \"Count\",\n    mean_body_mass = \"Mean body mass (g)\",\n    median_flipper = \"Median flipper (mm)\"\n  ) %&gt;%\n  fmt_number(columns = vars(mean_body_mass, median_flipper), decimals = 1)\n\nWarning: Since gt v0.3.0, `columns = vars(...)` has been deprecated.\n• Please use `columns = c(...)` instead.\n\n\n\n\n\n\n\n\n\nCount\nMean body mass (g)\nMedian flipper (mm)\n\n\n\n\nAdelie\n146\n3,706.2\n190.0\n\n\nChinstrap\n68\n3,733.1\n196.0\n\n\nGentoo\n119\n5,092.4\n216.0\n\n\n\n\n\n\n\n\nGrouped details plus summary rows Show species groups with a grand summary row.\n\n\npenguins_clean %&gt;%\n  group_by(species) %&gt;%\n  slice_sample(n = 6) %&gt;%    # small sample per species for display\n  ungroup() %&gt;%\n  gt(groupname_col = \"species\") %&gt;%\n  summary_rows(\n    groups = TRUE,\n    columns = c(\"body_mass_g\"),\n    fns = list(\n      \"avg (g)\" = ~mean(., na.rm = TRUE),\n      \"min (g)\" = ~min(., na.rm = TRUE),\n      \"max (g)\" = ~max(., na.rm = TRUE)\n    )\n  ) %&gt;%\n  grand_summary_rows(\n    columns = c(\"body_mass_g\"),\n    fns = list(\"Overall avg (g)\" = ~mean(., na.rm = TRUE))\n  ) %&gt;%\n  fmt_number(columns = vars(body_mass_g), decimals = 0)\n\nWarning: Since gt v0.3.0, `columns = vars(...)` has been deprecated.\n• Please use `columns = c(...)` instead.\n\n\n\n\n\n\n\n\n\nisland\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\nsex\n\n\n\n\nAdelie\n\n\n\nTorgersen\n42.8\n18.5\n195\n4,250\nmale\n\n\n\nBiscoe\n36.5\n16.6\n181\n2,850\nfemale\n\n\n\nDream\n37.0\n16.9\n185\n3,000\nfemale\n\n\n\nTorgersen\n40.3\n18.0\n195\n3,250\nfemale\n\n\n\nDream\n35.7\n18.0\n202\n3,550\nfemale\n\n\n\nTorgersen\n39.0\n17.1\n191\n3,050\nfemale\n\n\nChinstrap\n\n\n\nDream\n58.0\n17.8\n181\n3,700\nfemale\n\n\n\nDream\n52.7\n19.8\n197\n3,725\nmale\n\n\n\nDream\n45.2\n17.8\n198\n3,950\nfemale\n\n\n\nDream\n42.5\n17.3\n187\n3,350\nfemale\n\n\n\nDream\n42.5\n16.7\n187\n3,350\nfemale\n\n\n\nDream\n52.8\n20.0\n205\n4,550\nmale\n\n\nGentoo\n\n\n\nBiscoe\n43.6\n13.9\n217\n4,900\nfemale\n\n\n\nBiscoe\n45.2\n15.8\n215\n5,300\nmale\n\n\n\nBiscoe\n50.2\n14.3\n218\n5,700\nmale\n\n\n\nBiscoe\n50.4\n15.3\n224\n5,550\nmale\n\n\n\nBiscoe\n46.5\n13.5\n210\n4,550\nfemale\n\n\n\nBiscoe\n46.5\n14.4\n217\n4,900\nfemale\n\n\nOverall avg (g)\n—\n—\n—\n—\n4081.944\n—",
    "crumbs": [
      "Data Manipulation",
      "Better tables with {gt}"
    ]
  },
  {
    "objectID": "02-wrangling/02-join.html",
    "href": "02-wrangling/02-join.html",
    "title": "Combining Data",
    "section": "",
    "text": "library(tidyverse)\nlibrary(palmerpenguins)\n\n# prepare a clean table for examples\npenguins_clean &lt;- penguins %&gt;%\n  select(species, island, year, bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g) %&gt;%\n  drop_na(species)\n\n\n\n\n# create a small metadata table that intentionally omits one species (to show filtering)\nspecies_meta &lt;- tibble(\n  species = c(\"Adelie\", \"Gentoo\"),       # note: \"Chinstrap\" is omitted\n  conservation_note = c(\"stable\", \"monitor\")\n)\n\n# inner_join keeps only rows that have a match in species_meta (Adelie + Gentoo only)\npenguins_inner &lt;- penguins_clean %&gt;%\n  inner_join(species_meta, by = \"species\")\n\n# inspect result counts per species (should not include Chinstrap)\npenguins_inner %&gt;% count(species)\n\n# A tibble: 2 × 2\n  species     n\n  &lt;chr&gt;   &lt;int&gt;\n1 Adelie    152\n2 Gentoo    124\n\n\n\n\n\n\n# compute island-level average body mass\nisland_summary &lt;- penguins_clean %&gt;%\n  group_by(island) %&gt;%\n  summarise(island_mean_mass = mean(body_mass_g, na.rm = TRUE), .groups = \"drop\")\n\n# left_join preserves all rows from penguins_clean and adds island_mean_mass\npenguins_with_island &lt;- penguins_clean %&gt;%\n  left_join(island_summary, by = \"island\")\n\n# verify: each row has island_mean_mass and original rows are preserved\npenguins_with_island %&gt;% slice_head(n = 6)\n\n# A tibble: 6 × 8\n  species island     year bill_length_mm bill_depth_mm flipper_length_mm\n  &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;          &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;\n1 Adelie  Torgersen  2007           39.1          18.7               181\n2 Adelie  Torgersen  2007           39.5          17.4               186\n3 Adelie  Torgersen  2007           40.3          18                 195\n4 Adelie  Torgersen  2007           NA            NA                  NA\n5 Adelie  Torgersen  2007           36.7          19.3               193\n6 Adelie  Torgersen  2007           39.3          20.6               190\n# ℹ 2 more variables: body_mass_g &lt;int&gt;, island_mean_mass &lt;dbl&gt;",
    "crumbs": [
      "Data Manipulation",
      "Combining Data"
    ]
  },
  {
    "objectID": "02-wrangling/02-join.html#joining-examples-with-palmerpenguins",
    "href": "02-wrangling/02-join.html#joining-examples-with-palmerpenguins",
    "title": "Combining Data",
    "section": "",
    "text": "library(tidyverse)\nlibrary(palmerpenguins)\n\n# prepare a clean table for examples\npenguins_clean &lt;- penguins %&gt;%\n  select(species, island, year, bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g) %&gt;%\n  drop_na(species)\n\n\n\n\n# create a small metadata table that intentionally omits one species (to show filtering)\nspecies_meta &lt;- tibble(\n  species = c(\"Adelie\", \"Gentoo\"),       # note: \"Chinstrap\" is omitted\n  conservation_note = c(\"stable\", \"monitor\")\n)\n\n# inner_join keeps only rows that have a match in species_meta (Adelie + Gentoo only)\npenguins_inner &lt;- penguins_clean %&gt;%\n  inner_join(species_meta, by = \"species\")\n\n# inspect result counts per species (should not include Chinstrap)\npenguins_inner %&gt;% count(species)\n\n# A tibble: 2 × 2\n  species     n\n  &lt;chr&gt;   &lt;int&gt;\n1 Adelie    152\n2 Gentoo    124\n\n\n\n\n\n\n# compute island-level average body mass\nisland_summary &lt;- penguins_clean %&gt;%\n  group_by(island) %&gt;%\n  summarise(island_mean_mass = mean(body_mass_g, na.rm = TRUE), .groups = \"drop\")\n\n# left_join preserves all rows from penguins_clean and adds island_mean_mass\npenguins_with_island &lt;- penguins_clean %&gt;%\n  left_join(island_summary, by = \"island\")\n\n# verify: each row has island_mean_mass and original rows are preserved\npenguins_with_island %&gt;% slice_head(n = 6)\n\n# A tibble: 6 × 8\n  species island     year bill_length_mm bill_depth_mm flipper_length_mm\n  &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;          &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;\n1 Adelie  Torgersen  2007           39.1          18.7               181\n2 Adelie  Torgersen  2007           39.5          17.4               186\n3 Adelie  Torgersen  2007           40.3          18                 195\n4 Adelie  Torgersen  2007           NA            NA                  NA\n5 Adelie  Torgersen  2007           36.7          19.3               193\n6 Adelie  Torgersen  2007           39.3          20.6               190\n# ℹ 2 more variables: body_mass_g &lt;int&gt;, island_mean_mass &lt;dbl&gt;",
    "crumbs": [
      "Data Manipulation",
      "Combining Data"
    ]
  },
  {
    "objectID": "01-plotting/02-multiplots.html",
    "href": "01-plotting/02-multiplots.html",
    "title": "Multi-plots",
    "section": "",
    "text": "library(tidyverse)\nlibrary(palmerpenguins)\n\n# brings 'penguins' dataset into name space\nattach(penguins)\n# brings 'penguins_raw' dataset into name space\nattach(penguins_raw)",
    "crumbs": [
      "Plotting",
      "Multi-plots"
    ]
  },
  {
    "objectID": "01-plotting/02-multiplots.html#setup",
    "href": "01-plotting/02-multiplots.html#setup",
    "title": "Multi-plots",
    "section": "",
    "text": "library(tidyverse)\nlibrary(palmerpenguins)\n\n# brings 'penguins' dataset into name space\nattach(penguins)\n# brings 'penguins_raw' dataset into name space\nattach(penguins_raw)",
    "crumbs": [
      "Plotting",
      "Multi-plots"
    ]
  },
  {
    "objectID": "01-plotting/02-multiplots.html#multi-plots-with-patchwork",
    "href": "01-plotting/02-multiplots.html#multi-plots-with-patchwork",
    "title": "Multi-plots",
    "section": "Multi-plots with Patchwork",
    "text": "Multi-plots with Patchwork\nThe {patchwork} package is great for assembling multiple plots into a single plot\nDocumentation for {patchwork}: https://patchwork.data-imaginist.com/index.html\n\nlibrary(patchwork)\n\nLets create some example plots that we can call upon\n\npenguin_point_plot &lt;- ggplot(\n  data = penguins,\n  mapping = aes(x = body_mass_g,\n                y = flipper_length_mm,\n                colour = island)\n) + \n  geom_point() +\n  ggtitle(\"Plot 1\")\n\n\npenguin_box_plot &lt;- ggplot(\n  data = penguins,\n  mapping = aes(x = species,\n                y = flipper_length_mm)\n) + \n  geom_boxplot() +\n  ggtitle(\"Plot2\")\n\n\nDifferent ways of combining plots\nside by side using +\n\npenguin_point_plot + penguin_box_plot\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_boxplot()`).\n\n\n\n\n\n\n\n\n\nOr use | to create columns in the layout\n\npenguin_point_plot | penguin_box_plot\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_boxplot()`).\n\n\n\n\n\n\n\n\n\nOne over the other using /\n\npenguin_point_plot / penguin_box_plot\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_boxplot()`).\n\n\n\n\n\n\n\n\n\nIncluding a table\n\nlibrary(gt)\npenguin_tab &lt;- penguins %&gt;% \n  group_by(species) %&gt;% \n  summarise(n = n()) %&gt;% \n  gt()  \n\n\npenguin_point_plot + penguin_tab\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\n\n\nControlling Layouts with plot_layout()\nThe {patchwork} package has the ability to control layouts through several methods (rows/columns, relative sizes, and custom designs). Below are short examples using the plots and table defined earlier.\n\nUse plot_layout() to set number of columns and relative widths/heights.\nUse parentheses to group stacked/side-by-side operators when you want to apply layout options to the combined result.\nUse a design string to create more complex placements (one plot spanning multiple cells).\nCollect legends with guides = “collect” and add a shared title with plot_annotation().\n\n\n# example plots\np1 &lt;- ggplot(penguins, aes(x = body_mass_g, y = flipper_length_mm, colour = species)) +\n  geom_point(na.rm = TRUE) + ggtitle(\"Mass vs Flipper\")\n\np2 &lt;- ggplot(penguins, aes(x = species, y = flipper_length_mm)) +\n  geom_boxplot(na.rm = TRUE) + ggtitle(\"Flipper by species\")\n\np3 &lt;- ggplot(penguins, aes(x = island, y = body_mass_g)) +\n  geom_violin(na.rm = TRUE) + ggtitle(\"Mass by island\")\n\n\nAn example two-column layout where p1 takes left column and p2/p3 stack on the right\n\n\nwidths is specifying the width of each column\n\n\n(p1 | (p2 / p3)) +\n  plot_layout(widths = c(2, 1)) +\n  plot_annotation(title = \"p1 large left, p2 & p3 stacked right\")\n\n\n\n\n\n\n\n\n\nGrid layout with relative widths/heights and a shared legend collected\n\n\n(p1 + p2 + p3) +\n  plot_layout(ncol = 2, widths = c(2, 1), heights = c(1, 1), guides = \"collect\") + #&\n  # theme(legend.position = \"bottom\") +\n  plot_annotation(tag_levels = \"A\")\n\n\n\n\n\n\n\n\n\nComplex placement using a design string (A spans 3 cells in row 1)\n\n\n# is used as a ‘spacer’ or empty plot\n\n\ndesign &lt;- \"\nAAA\nB#C\n\"\np1 + p2 + p3 + plot_layout(design = design) +\n  plot_annotation(title = \"Design string layout\")\n\n\n\n\n\n\n\n\nAlternatively, plot_spacer() can be used in the plot specification and it’s treated as a plot within the design (instead of using “#”).\n\ndesign &lt;- \"\nAAA\nBCD\n\"\np1 + p2 + plot_spacer() + p3 + plot_layout(design = design) +\n  plot_annotation(title = \"Design string layout\")\n\n\n\n\n\n\n\n\nNotes: use widths/heights for relative sizing, guides = “collect” to share legends, and a design string for precise cell placement.",
    "crumbs": [
      "Plotting",
      "Multi-plots"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Beyond Intro R",
    "section": "",
    "text": "The goal of this workshop is to build upon “introductory content” that is found in other workshops such as Data Carpentry - Data Analysis and Visualisation for Ecologists.\nThe workshop itself is a bit piecemeal and covers a range of topics and is mostly designed as a source of quick reference for the instructor during the session\nThe key themes of the workshop are to:\nThe main reference material is the package documentation itself",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#r-syntax-refresher",
    "href": "index.html#r-syntax-refresher",
    "title": "Beyond Intro R",
    "section": "R Syntax Refresher",
    "text": "R Syntax Refresher\n\nMaths\nMathematical operations:\n\n+ and - for addition and subtraction\n*, /, and %% for multiplication, division, and remainder division\n^ for exponentiation\n( and ) for bracketing\nPrecedence of operators follows BEDMAS\n\n\n1 + 6\n\n[1] 7\n\n5 - 3\n\n[1] 2\n\n2 * 9\n\n[1] 18\n\n8 / 4\n\n[1] 2\n\n9 %% 2\n\n[1] 1\n\n2 ^ 3\n\n[1] 8\n\n\nAssignment\n\na &lt;- 7\n\na\n\n[1] 7\n\n\nVectors\n\nmust be all of the same type\n\nnumeric\ncharacter\nboolean\n\n\n\nb &lt;-c(2, 5, 6)\n\nIndexing (starts from 1)\n\n# 3rd item\nb[3]\n\n[1] 6\n\n# Exclude the 2nd item\nb[-2]\n\n[1] 2 6\n\n\nSubsetting with by comparison\n\n# items in b larger than 3\nb[ b &gt; 3]\n\n[1] 5 6\n\n# items in b that are equal to 6\nb[ b == 6]\n\n[1] 6",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "03-programming/02-purrr.html",
    "href": "03-programming/02-purrr.html",
    "title": "Mapping Functions",
    "section": "",
    "text": "In the package purrr (part of package tidyverse), there are a collection of map functions which iterate over a vector or list, applying a function to each element. This is a very succinct syntax, which achieves the same result as calling the function inside a for loop, without the overhead of writing out the loop structure.\n\nlibrary(purrr)\n\nfarenheit_to_celcius &lt;- function(temp_f){\n  temp_c &lt;- (temp_f - 32) * 5/9\n  return(temp_c)\n}\n\nmy_temps_f &lt;- c(90, 78, 88, 89, 77)\n\n# map applies the function (2nd argument) to each element of the vector (1st argument) \n# and returns the results as a list. \nmy_temps_c_list &lt;- map(my_temps_f, farenheit_to_celcius)\nmy_temps_c_list\n\n[[1]]\n[1] 32.22222\n\n[[2]]\n[1] 25.55556\n\n[[3]]\n[1] 31.11111\n\n[[4]]\n[1] 31.66667\n\n[[5]]\n[1] 25\n\n\nThe map argument names are .x and .f, so the call to map above could also be written as my_temps_c_list &lt;- map(.x = my_temps_f, .f = farenheit_to_celcius)\nNote that when providing a function as an argument, give only the function name. Do not follow the function name with () as for a function call.\n\n\nThe basic form of map above, returns the results in a list. There are suffix versions of map that return the results as a specific data type.\n\nmap() makes a list.\nmap_lgl() makes a logical vector.\nmap_int() makes an integer vector.\nmap_dbl() makes a double vector.\nmap_chr() makes a character vector.\n\nThese suffix versions will give an error if the data type of the results doesn’t match the intended return type. This is useful because you can write code to process the results further, confident that they are of a specific data type.",
    "crumbs": [
      "Programming",
      "Mapping Functions"
    ]
  },
  {
    "objectID": "03-programming/02-purrr.html#map-and-friends",
    "href": "03-programming/02-purrr.html#map-and-friends",
    "title": "Mapping Functions",
    "section": "",
    "text": "The basic form of map above, returns the results in a list. There are suffix versions of map that return the results as a specific data type.\n\nmap() makes a list.\nmap_lgl() makes a logical vector.\nmap_int() makes an integer vector.\nmap_dbl() makes a double vector.\nmap_chr() makes a character vector.\n\nThese suffix versions will give an error if the data type of the results doesn’t match the intended return type. This is useful because you can write code to process the results further, confident that they are of a specific data type.",
    "crumbs": [
      "Programming",
      "Mapping Functions"
    ]
  },
  {
    "objectID": "03-programming/01-functions.html",
    "href": "03-programming/01-functions.html",
    "title": "Custom Functions",
    "section": "",
    "text": "Originally from R for Successful Student Projects a custom R course made by eResearch Support at University of Otago",
    "crumbs": [
      "Programming",
      "Custom Functions"
    ]
  },
  {
    "objectID": "03-programming/01-functions.html#creating-a-function",
    "href": "03-programming/01-functions.html#creating-a-function",
    "title": "Custom Functions",
    "section": "Creating a function",
    "text": "Creating a function\nWe will begin with the simplest function, one that accepts no input data, and returns no result. We declare the function using keyword function. Schematically, a user-defined function is created as:\nname_of_function &lt;- function()\n{\n   Code Body\n}\nThe curly braces enclose the code body.\nSubesquently we call the function as:\nname_of_function()\nWhen the call is executed, all the commands in the code body are run.\nFor example, in the current public health situation, we often see discussions of what body temperature constitutes a fever. We might want to be able to translate that temperature from Celsius to Fahrenheit (as used in the North American literature). This is a logically well-delineated computation, so we would encapsulate it in a function.\n\n# Declare/define the function\nfever_in_fahrenheit &lt;- function()\n{\n  fever_in_celsius &lt;- 37.5\n  converted_to_fahrenheit &lt;-(fever_in_celsius*9/5) + 32\n  print(converted_to_fahrenheit)\n}\n\n\n# Call a user-defined function by name\nfever_in_fahrenheit()\n\n[1] 99.5\n\n\nSome things to note:\n\nTyping out the function declaration is not enough to make the function available for calling. The declaration code (from the start of the name to the closing curly bracket, inclusive) must first be executed. Execute this code in a script as we always do, by selecting all the code (with the mouse) and typing ctrl-Enter (Windows) or cmd-Enter (Mac). This is called sourcing the function.\nWhen you source a function, nothing happens. In our example, you will not see the output of the print statement when you execute the declaration code. Sourcing a function declaration does not run the code body. It simply parses the code body and, if there are no errors, stores it in the environment. Effectively, it informs RStudio that a function with this name exists, and defines the code which it encapsulates, so it can be called later.\nTo execute the code body, state the name of the function followed by (), with no intervening spaces. This calls the function; we think of () as the call operator. Whether the code body contains 1 line or 1,000 lines, or more, calling the function by name runs all the encapsulated code.\n\nIn R a function cannot be called until after the function has been sourced. Consider the following example:\n\n# If you try to call the function before it is declared and sourced\nfever_in_fahrenheit()\n\nError in fever_in_fahrenheit(): could not find function \"fever_in_fahrenheit\"\n\nfever_in_fahrenheit &lt;- function()\n{\n  fever_in_celsius &lt;- 37.5\n  converted_to_fahrenheit &lt;-(fever_in_celsius*9/5) + 32\n  print(converted_to_fahrenheit)\n}\n\nThere are more advanced techniques that allow us to call functions contained in other script files where we cannot directly select and execute the declaration code. See the reading for discussion.",
    "crumbs": [
      "Programming",
      "Custom Functions"
    ]
  },
  {
    "objectID": "03-programming/01-functions.html#providing-data-to-a-function",
    "href": "03-programming/01-functions.html#providing-data-to-a-function",
    "title": "Custom Functions",
    "section": "Providing data to a function",
    "text": "Providing data to a function\nConsider the following function, which demonstrates how to compute BMI (body mass index) in R, using the given values for height (in metres) and weight (in kg):\n\n# Declare function calc_BMI\ncalc_BMI &lt;- function()\n{\n  weight &lt;- 73\n  height &lt;- 1.68\n  bmi &lt;- weight/height^2 # ^ is the exponentiation operator\n  \n  print(bmi)\n}\n\n# Call function calc_BMI\ncalc_BMI()\n\n[1] 25.86451\n\n\nThis function contains nice tidy code and is mathematically correct, but unless we happen to want the BMI of a person with exactly this height and weight, it is of no use to us. A useful function defines the computation (in this case taking the ratio of weight to height squared), and accepts the data values when it is called.\nWe have seen this many times when writing R code, when we call a function repeatedly on different input values:\n\nsqrt(14)\n\n[1] 3.741657\n\nsqrt(820)\n\n[1] 28.63564\n\nsqrt(0.65)\n\n[1] 0.8062258\n\n\nTo declare a function that can accept input arguments, perform these steps:\n\nBetween the round brackets that follow the keyword function, place a variable name for each piece of data you wish to input when the function is called.\nIn the function body refer to the input variables by the name you placed between the round brackets. You DO NOT need to initialise the variables inside the code body – in fact you MUST NOT do so. Variables with those names are automatically created for you when the function is called.\nWhen calling the function, provide a value for each input variable. You do not need to repeat the variable name, just provide values, separated by commas, in the same order as the variables are listed in the declatration.\nWhen the function is called, the system creates the input variables, assigns them the corresponding values from the call statement, and executes the code body, using those variables.\n\nWe can modify our calc_BMI function to accept weight and height as input variables, as shown. Compare this version to the earlier version. Note that we do not declare and initialise weight and height inside the code body.\n\n# Declare function calc_BMI\ncalc_BMI &lt;- function(weight, height)\n{\n  # Use input arguments weight and height. DON'T initialise them.\n  bmi &lt;- weight/height^2\n  \n  print(bmi)\n}\n\n# Call function calc_BMI\ncalc_BMI(73, 1.68)\n\n[1] 25.86451\n\n\n\nFollowing the rules\nDeclaring a function with inputs defines the required interface of the function. That is, it defines what you have to provide if you want to call the function. If the caller violates the interface, the code is not guaranteed to work. For example, function calc_bmi is declared with two input arguments. Therefore, all of these calls violate the interface.\n\ncalc_BMI()\n\nError in calc_BMI(): argument \"weight\" is missing, with no default\n\n\n\ncalc_BMI(16)\n\nError in calc_BMI(16): argument \"height\" is missing, with no default\n\n\n\ncalc_BMI(73, 168, 42)\n\nError in calc_BMI(73, 168, 42): unused argument (42)\n\n\nIn some programming languages, one is required to specify the data type (e.g. number, string, data frame, etc.) of each input argument. Code that tries to pass in the wrong type of data will not compile. In R this is not required. R will try to run your code no matter what sort of data it gets. However, if it tries to operate on the wrong type of data, it will throw an error:\n\ncalc_BMI(42, \"fred\")\n\nError in height^2: non-numeric argument to binary operator\n\n\nNaturally, R doesn’t understand how to apply the exponentiation operator to “fred”, and it is telling you so.\n\n\nMore on the rules\nConsider the following code:\n\n# Declare the function\ncompute_area &lt;- function(width)\n{\n  area &lt;- width * height\n  print(area)\n}\n\n# Call the function\ncompute_area(35)\n\nThe function compute_area is defined with one argument. Therefore, when it is called, we must provide one value between the round brackets. In the call, we have correctly provided one argument, of the correct data type. Will the call compute_area(35) work correctly, or will it throw an error? What error will it throw?\n\n# Declare the function\ncompute_area &lt;- function(width)\n{\n  area &lt;- width * height\n  print(area)\n}\n\n# Call the function\ncompute_area(35)\n\nError in compute_area(35): object 'height' not found\n\n\nWhen compute_area(35) is executed, it produces an error message: ...object 'height' not found. In the code body of compute_area, we refer to an entity height. Since that entity is not surrounded by double-quotes, R expects to find a variable named height existing in the environment, and no such variable exists, because we have neither created one directly (with an assignment statement) nor passed one in as an argument to the function.\nIn the same line of code, we also refer to an entity width. Note that R does not complain about being unable to find width. That is because we defined an input argument called width.\n\nHow would you modify function compute_area to eliminate the error?\nHow would this change the form of the call to compute_area?\n\n\n\nTaking your time\nTraditionally, new programmers find the syntax of argument passing extremely confusing. There are too many interacting parts: we have variable names in the declaration, variables used in the code body, and values passed in the call. At first exposure, it can be unclear how all these parts work together. If this is the first time you have seen this syntax, take some time to experiment with it to solidify your understanding. Make up some simple user defined functions of your own to practice managing input data.",
    "crumbs": [
      "Programming",
      "Custom Functions"
    ]
  },
  {
    "objectID": "03-programming/01-functions.html#getting-output-from-a-function",
    "href": "03-programming/01-functions.html#getting-output-from-a-function",
    "title": "Custom Functions",
    "section": "Getting output from a function",
    "text": "Getting output from a function\nIn all of our examples so far, we have used a print statement to show the result of the function’s computation. This is, of course, not adequate in real programming, as a print statement simply writes to the console. The computed value is not available for use later in our script. We want to be able to save the result of a function into a variable, as we have done with the built-in functions we have used earlier in the course. For example, we have said x &lt;- sqrt(22), creating a variable called x that stores the square root of 22. We could then use x in subsequent computations, as needed.\nWhen a function makes its result available for storage, we say it is returning its result. The command sqrt(22) returns the square root of 22, and we can store it in a variable using the assignment statement.\nWe can make our user-defined function behave in the same way, by using return instead of print. For example, we can modify calc_bmi:\n\n# Declare function calc_BMI\ncalc_BMI &lt;- function(weight, height)\n{\n  bmi &lt;- weight/height^2 # ^ is the exponentiation operator\n  \n  return(bmi)\n}\n\nWith this change to the function, we can store the result of the BMI computation in a variable for later use.\n\n# Save the return value in a variable.\nbmi_result &lt;- calc_BMI(75, 1.75)\n\n# Display by name, as we always can do in R with variables\nbmi_result\n\n[1] 24.4898\n\n\n\nCAUTION\nIn R, the return keyword is actually optional. By default, R functions just return the value of their last line of code. So technically, you can write the function above like this without changing its behaviour:\n\n# Declare function calc_BMI\ncalc_BMI &lt;- function(weight, height)\n{\n  bmi &lt;- weight/height^2 # ^ is the exponentiation operator\n  \n  # Omitting the explicit call to return. Don't do this.\n  bmi\n}\n\nYou will see this shortcut used in R code in the wild. However, it is an old-fashioned syntax, and it can lead to subtle errors in complex R programs. We suggest that you avoid it. Make the behaviour of your functions clear by explicitly identifying the return value with function return.",
    "crumbs": [
      "Programming",
      "Custom Functions"
    ]
  },
  {
    "objectID": "03-programming/01-functions.html#function-exercise",
    "href": "03-programming/01-functions.html#function-exercise",
    "title": "Custom Functions",
    "section": "Function exercise",
    "text": "Function exercise\nReturning to the Palmers Penguins data, and using the techniques we have seen for performing descriptive statistics, consider the following code, which computes summaries of the body mass measure (i.e. the dependent variable in this summary is column body_mass_g).\n\nlibrary(palmerpenguins)\n\ndv_vector &lt;- penguins$body_mass_g\n\nmean_dv &lt;- mean(dv_vector, na.rm = TRUE)\nsd_dv &lt;- sd(dv_vector, na.rm = TRUE)\nmin_dv &lt;- min(dv_vector, na.rm = TRUE)\nmax_dv &lt;- max(dv_vector, na.rm = TRUE)\n\nThis code fragment creates four new variables that we could use in later computations, or in generating reports.\nImagine that we wish to do the same summary for flipper length. We could copy and paste the code, changing the line where we assign variable dv_vector. Then if we wanted to do the same summary on bill length, we could copy and paste the code again, and again change the assignment to dv_vector. By now, we are bored of this, and our script is getting needlessly big and messy. If we later decide we need to include the median, we will need to go back and add the median command multiple times, greatly increasing the chance of errors (and also being boring).\nComputing this set of descriptive stats is a logically delineated task, and we should therefore encapsulate it into a user defined function. Each time we do this summary, the computation (the four calls to mean, sd, min and max) remains the same, but the data we wish to process changes. Each time we call the function, we want to be able to provide it with the data to process. We must therefore pass the data in as an input argument.\n\nMake a function with input arguments\nConvert this code into a function that accepts a single input argument, which will be the vector of data to be analysed. For now, use print statements to display the results, not return statements, so we can concentrate on getting the data in. Call your function desc_stats.\n\nlibrary(palmerpenguins)\n\ndesc_stats &lt;- function(dv_vector)\n{\n  mean_dv &lt;- mean(dv_vector, na.rm = TRUE)\n  sd_dv &lt;- sd(dv_vector, na.rm = TRUE)\n  min_dv &lt;- min(dv_vector, na.rm = TRUE)\n  max_dv &lt;- max(dv_vector, na.rm = TRUE)\n\n  print(mean_dv)\n  print(sd_dv)\n  print(min_dv)\n  print(max_dv)\n}  \n\nSource the function by selecting all the code (from before desc_stats down to and including the closing curly bracket) and typing ctrl-Enter or cmd-Enter. Test your function by calling it on the body mass data, the flipper length data, and the bill length data.\n\ndesc_stats(penguins$body_mass_g)\n\n[1] 4201.754\n[1] 801.9545\n[1] 2700\n[1] 6300\n\ndesc_stats(penguins$flipper_length_mm)\n\n[1] 200.9152\n[1] 14.06171\n[1] 172\n[1] 231\n\ndesc_stats(penguins$bill_length_mm)\n\n[1] 43.92193\n[1] 5.459584\n[1] 32.1\n[1] 59.6\n\n\nStop to admire how tidy and succinct your code is. Note that if you now decide to add the median, you only need to make the change in one place – in the function declaration itself – regardless of how many different data sets you have processed.\nNB: If you do change the function, you must source the function again (i.e. you must repeat the “select all the function code and type ctrl-enter” step) to update R’s stored copy of the function. You will not see any change in behaviour until the modified function code is sourced.\n\n\nGet output from the function\nAs discussed earlier, displaying function output via print statements is of limited utility; it is preferable to return the results of a function, so it can be stored in a variable. We would like, therefore, to return the output of function desc_stats. Unfortunately, a function in R can only return a single data object and our function computes four values.\nTo resolve this, we can bundle up our four computed values into a single data object, called a list. An R list is like a vector, except that each element has a name as well as an ordinal position, and elements can be retrieved (using the [] operator) either by name or position. Consider this example:\n\n# Create a list\ncharacter_list &lt;- list(Name = \"Snoopy\", Breed = \"Beagle\", Owner = \"Charlie Brown\")\n\n# Display the entire list\ncharacter_list\n\n$Name\n[1] \"Snoopy\"\n\n$Breed\n[1] \"Beagle\"\n\n$Owner\n[1] \"Charlie Brown\"\n\n# Some examples of selection from the list\ncharacter_list[\"Name\"]\n\n$Name\n[1] \"Snoopy\"\n\ncharacter_list[\"Breed\"]\n\n$Breed\n[1] \"Beagle\"\n\ncharacter_list[2]\n\n$Breed\n[1] \"Beagle\"\n\ncharacter_list[3]\n\n$Owner\n[1] \"Charlie Brown\"\n\ncharacter_list$Name\n\n[1] \"Snoopy\"\n\ncharacter_list$Owner\n\n[1] \"Charlie Brown\"\n\n\nA list is considered a single data object, so it can be returned from a function via a return statement. Modify function desc_stats to return its four outputs, rather than printing them. Call your function and use any of the syntactic options above to explore the contents of the returned object.\nMy solution is:\n\n# Modify the function to return a list\ndesc_stats &lt;- function(dv_vector)\n{\n  mean_dv &lt;- mean(dv_vector, na.rm = TRUE)\n  sd_dv &lt;- sd(dv_vector, na.rm = TRUE)\n  min_dv &lt;- min(dv_vector, na.rm = TRUE)\n  max_dv &lt;- max(dv_vector, na.rm = TRUE)\n\n  result_list &lt;- list(Mean = mean_dv,\n                      Sd = sd_dv,\n                      Min = min_dv,\n                      Max = max_dv)\n  \n  return(result_list)\n}\n\n\nflipper_desc_stats &lt;- desc_stats(penguins$flipper_length_mm)\n\nflipper_desc_stats$Mean\n\n[1] 200.9152\n\nflipper_desc_stats[2]\n\n$Sd\n[1] 14.06171\n\nmin_max &lt;- c(flipper_desc_stats[\"Min\"], flipper_desc_stats[\"Max\"])\n\nprint(min_max)\n\n$Min\n[1] 172\n\n$Max\n[1] 231",
    "crumbs": [
      "Programming",
      "Custom Functions"
    ]
  },
  {
    "objectID": "03-programming/01-functions.html#if-statements",
    "href": "03-programming/01-functions.html#if-statements",
    "title": "Custom Functions",
    "section": "If statements",
    "text": "If statements\nAll modern programming languages allow you to wrap a block of code in an if statement. If statements contain a condition, which is an expression which evaluates to either true or false. At runtime, the condition is evaluated. If it is true, the block of code is executed; if it is false, the block of code is not executed. Conditional code blocks in R are delineated with curly brackets. The conditional expression is delineated with round brackets.\nSchematically:\n\nif (condition) {\n  # code here is only run if condition was TRUE\n}\n\nConsider this toy example:\n\ndid_I_pass_the_paper &lt;- function(my_mark)\n{\n  if (my_mark &gt; 50) {\n    print(\"You passed!\")\n  }\n}\n\n# This call generates no output\ndid_I_pass_the_paper(14)\n\n# This call generates output\ndid_I_pass_the_paper(73)\n\n[1] \"You passed!\"",
    "crumbs": [
      "Programming",
      "Custom Functions"
    ]
  },
  {
    "objectID": "03-programming/01-functions.html#adding-an-alternative-with-else",
    "href": "03-programming/01-functions.html#adding-an-alternative-with-else",
    "title": "Custom Functions",
    "section": "Adding an alternative with else",
    "text": "Adding an alternative with else\nFrequently we wish to define two behaviours for a conditional expression – one for when it is true and another for when it is false. In R we do this with the keyword else\n\nif (condition) {\n  # code here is only run if condition was TRUE\n} else {\n  # code here is only run if condition was FALSE\n}\n\nFor example:\n\ndid_I_pass_the_paper &lt;- function(my_mark)\n{\n  if (my_mark &gt; 50) {\n    print(\"You passed! :)\")\n  } else {\n    print(\"Sorry, you didn't pass. :(\")\n  }\n}\n\n# This call runs the else block\ndid_I_pass_the_paper(14)\n\n[1] \"Sorry, you didn't pass. :(\"\n\n# This call runs the if block\ndid_I_pass_the_paper(73)\n\n[1] \"You passed! :)\"\n\n\nNB: Pay careful attention to the placement of the curly brackets for both the if block and the else block. The first curly bracket must sit on the same line as the if statement. The else keyword must be on the same line as the closing curly bracket of the if block, and must be followed, on that same line, by the opening curly bracket of the else block. It is a known peculiarity of the R language that it is extremely fussy about this rule. No use fighting it; just follow the rule.\nAn extension of else is the else if construct that lets you link a series of conditions. The conditions are tested one at a time from the top and the first condition that evaluates to TRUE is the only code block that gets run. For example:\n\nbmi_category &lt;- function(bmi)\n{\n    if(bmi &gt; 30){\n      print(\"obese\")\n    } else if (bmi &gt; 25){\n      print(\"overweight\")\n    } else if (bmi &gt; 20){\n      print(\"healthy\")\n    } else {\n      print(\"underweight\")\n  }\n}\n\n\nbmi_category(22)\n\n[1] \"healthy\"\n\nbmi_category(18)\n\n[1] \"underweight\"\n\n\nConditional statements can be nested. That is, inside the if or else block, you can have more conditional statements, each of which can have if and else blocks, each of which can in turn have nested conditional statements, and so on. For complex computations, the conditional logic can become very elaborate, and needs to be approached carefully. I find it helpful in these cases to sketch out a flow chart showing all the different outcomes based on state, and use that as a pattern for writing and arranging the various code blocks.",
    "crumbs": [
      "Programming",
      "Custom Functions"
    ]
  },
  {
    "objectID": "03-programming/01-functions.html#complex-conditional-expressions",
    "href": "03-programming/01-functions.html#complex-conditional-expressions",
    "title": "Custom Functions",
    "section": "Complex conditional expressions",
    "text": "Complex conditional expressions\nIn our previous examples, we wrote conditional expressions using the &gt; (greater than) operator. The expression my_mark &gt; 50 evaluates to either true or false (i.e. a boolean value). If variable my_mark is greater than 50, the expression returns true, otherwise it returns false. Greater than is a comparison operator. The R comparison operators are:\n\n\n\nOperator\nMeaning\n\n\n\n\n==\nequal to\n\n\n!=\nnot equal to\n\n\n&lt;\nless than\n\n\n&lt;=\nless than or equal to\n\n\n&gt;\ngreater than\n\n\n&gt;=\ngreater than or equal to\n\n\n\nThe Boolean logic operators can be used in to modify or combine conditional expressions.\n\n\n\nBoolean Operation\nSymbol in R\n\n\n\n\nNOT\n!\n\n\nOR\n|\n\n\nAND\n&\n\n\n\nFor example, the following function might be used to check that a value entered as a penguin body mass was within the expected weight range for the species.\n\n# Chinstrap penguins weight between 3 and 5 kg\n\ncheck_chinstrap_weight &lt;- function(weight_to_check)\n{\n  if ((weight_to_check &gt;= 3000) & (weight_to_check &lt;= 5000)) {\n    print(\"Weight ok\")\n  } else {\n    print(\"That's probably a typo\")\n  }\n}\n\n\ncheck_chinstrap_weight(4100)\n\n[1] \"Weight ok\"\n\ncheck_chinstrap_weight(410)\n\n[1] \"That's probably a typo\"\n\n\nThe result of the NOT, AND, and OR are shown in the logic table:\n\n\n\nStatement\nBecomes\n\n\n\n\n\n\n!TRUE\nFALSE\n\n\n\n\n!FALSE\nTRUE\n\n\n\n\nTRUE & TRUE\nTRUE\n\n\n\n\nTRUE & FALSE\nFALSE\n\n\n\n\nFALSE & TRUE\nFALSE\n\n\n\n\nFALSE & FALSE\nFALSE\n\n\n\n\nTRUE | TRUE\nTRUE\n\n\n\n\nTRUE | FALSE\nTRUE\n\n\n\n\nFALSE | TRUE\nTRUE\n\n\n\n\nFALSE | FALSE\nFALSE",
    "crumbs": [
      "Programming",
      "Custom Functions"
    ]
  },
  {
    "objectID": "03-programming/01-functions.html#conditional-exercise",
    "href": "03-programming/01-functions.html#conditional-exercise",
    "title": "Custom Functions",
    "section": "Conditional exercise",
    "text": "Conditional exercise\nWrite and test a function that determines whether a student receives a passing grade on an assessment. The function should accept two input args: the number of marks earned, and the total number of marks possible for the assessment. The student must earn 50% of the available marks in order to pass. For example, if a student earns 18 marks on a 20 mark assessment they pass, but if they earn only 8 marks, they fail. Your function should print “Pass” or “Fail” as appropriate based on the input data.\n\npass_check &lt;- function(earned, possible)\n{\n  mark &lt;- earned/possible\n  \n  if (mark &gt; 0.5){\n    print(\"Pass\")\n  } else {\n    print(\"Fail\")\n  }\n  \n}\n\n\npass_check(18, 20)\n\n[1] \"Pass\"\n\npass_check(8,20)\n\n[1] \"Fail\"\n\npass_check(18,100)\n\n[1] \"Fail\"\n\npass_check(8,10)\n\n[1] \"Pass\"",
    "crumbs": [
      "Programming",
      "Custom Functions"
    ]
  },
  {
    "objectID": "03-programming/01-functions.html#failing",
    "href": "03-programming/01-functions.html#failing",
    "title": "Custom Functions",
    "section": "Failing",
    "text": "Failing\nOne of the sayings in programming is “if it’s going to fail, it’s best to fail early”. That is, if we know that our function requires a specific input data type, we want to program defensively so that our function “fails” before it encounters the error. As part of our defensive programming we can provide informative error messages, rather than rely on R’s generic ones.\nIn the following example, we check that the data coming into our function is numeric. If it is not, we use function stop, to exit the function, displaying our informative message.\n\n# Returns the provided number doubled\ndouble_number &lt;- function(x) {\n  if( !is.numeric(x) ){\n    stop(\"x needs to be a number.\")\n  }\n  x * 2\n}\n\n\ndouble_number(4)\n\n[1] 8\n\ndouble_number(\"a\")\n\nError in double_number(\"a\"): x needs to be a number.\n\n\nN.B. Check the appendix for more on data types.",
    "crumbs": [
      "Programming",
      "Custom Functions"
    ]
  },
  {
    "objectID": "03-programming/01-functions.html#data-types",
    "href": "03-programming/01-functions.html#data-types",
    "title": "Custom Functions",
    "section": "Data types",
    "text": "Data types\nNot all data are created equal, in R this concept is captured by data types. For a vector, all values must be of a single data type.\nThe main data types that you will encounter in R are:\n\nLogical ( c(TRUE, FALSE))\nNumeric - also called Real or Double (Numbers that have a floating point (decimal) representation e.g. c(1, 3.6, 1e3))\nCharacter - also called String (anything inside matching opening and closing quotes (single or double) e.g. c(\"a\", \"some words\", \"animal\"))\n\nThere are 3 other less common:\n\nInteger (integers c(1L, 4L, -3L))\nComplex (Complex numbers e.g. c(0+3i, 4i, -2-5i))\nRaw (the bytes of a file)\n\nEach data type is known in R as an atomic vector. R has built in functions to be able to determine the data type of a vector, typeof() is the best one to use, but others such as str() and class() can be used.\nThere is also a series of functions that let us do explicit checking for a data type which will return TRUE or FALSE:\n\nis.logical()\nis.numeric() or is.double()\nis.character()\nis.integer()\nis.complex()\nis.raw()\n\n\nData Type Coercion\nIn R, when doing operations on multiple vectors, they all need to be the same data type - but how can this work if we have for example a numeric vector and a character vector? Coercion is how R deals with trying to operate on two vectors of different data types. What this means in practice is that R will convert the data type of a vector in a defined manner such that we end up will all of the same type and follows a “lowest common data type” approach. Using the 3 main data types from above, the following is the order in which they will be coerced into the next data type: logical -&gt; numeric -&gt; character.\nThis principle applies when you try to create a vector of mixed data types too, R will coerce everything until it is a single data type.\nSee if you can predict what data type the result will be (you can check by using typeof():\n\n# logical and numeric\nc(4, TRUE, 5)\n\n# numeric and character\nc(1, 3, \"A\")\n\n# logical and character\nc(FALSE, \"cat\",\"frog\")\n\n# mixed\nc(\"see\", TRUE, 4.8)\n\n# tricky\nc(\"1.3\", \"4\", TRUE)\n\nWe can also explicitly force coercion into a particular data type by using the following:\n\nas.logical()\nas.numeric()\nas.character()",
    "crumbs": [
      "Programming",
      "Custom Functions"
    ]
  },
  {
    "objectID": "01-plotting-overview.html",
    "href": "01-plotting-overview.html",
    "title": "Plotting Overview and Refresher",
    "section": "",
    "text": "Resources:",
    "crumbs": [
      "Plotting"
    ]
  },
  {
    "objectID": "01-plotting-overview.html#refresher",
    "href": "01-plotting-overview.html#refresher",
    "title": "Plotting Overview and Refresher",
    "section": "Refresher",
    "text": "Refresher\nA more in depth intro to ggplot2 is covered in Data Carpentry - Data Analysis and Visualisation for Ecologists. This is a brief overview/refresher.\n\nSetup\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\n# brings 'penguins' dataset into name space\nattach(penguins)\n# brings 'penguins_raw' dataset into name space\nattach(penguins_raw)\n\n\n\nBasics of Plotting with {ggplot2}\nThe basic premise of ggplot is that there are 3 main components to a plot:\n\nthe data\na mapping of the data to aesthetics of the plot e.g. x or y axes\n\nthis can be done for all layers of a plot at once by including it within the aes() within the ggplot() function\nor to specific layers by using aes() within a geom function\n\na geometric representation of the data e.g points, bars, boxplot\n\nand the plots are built in layers\n\n# general structure for a ggplot\nggplot(data = &lt;DATA&gt;, mapping = aes(&lt;MAPPINGS&gt;)) + &lt;GEOM_FUNCTION&gt;()\n\n\nggplot(\n  data = penguins,\n  mapping = aes(x = body_mass_g,\n                y = flipper_length_mm)\n) +\n  geom_point()\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nAnd we can modify the properties of layer to a specific value\n\nggplot(\n  data = penguins,\n  mapping = aes(x = body_mass_g,\n                y = flipper_length_mm)\n) +\n  geom_point(colour = \"blue\")\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nOr the property can be mapped back to the data - when this is the case we use aes()\n\nggplot(\n  data = penguins,\n  mapping = aes(x = body_mass_g,\n                y = flipper_length_mm)\n) +\n  geom_point(mapping = aes(colour = island))\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nPlots can also be built incrementally by assignment\n\npenguin_plot &lt;- ggplot(\n  data = penguins,\n  mapping = aes(x = body_mass_g,\n                y = flipper_length_mm,\n                colour = island)\n) \n\npenguin_plot &lt;- penguin_plot +\n  geom_point()\n\npenguin_plot\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).",
    "crumbs": [
      "Plotting"
    ]
  },
  {
    "objectID": "03-programming/03-env.html",
    "href": "03-programming/03-env.html",
    "title": "R Configuration",
    "section": "",
    "text": "As part setting R up to work best for us, we’re also wanting to make things easier on ourselves to that we can be more productive during the “do stuff” stage.\nThere is a hidden file called .Rprofile which is loaded as R launches and is a place where you can place customisations of options to make your R life easier. For instance I have mine set to automatically load workflow helper packages such as {usethis} {testthat} and {devtools}. And set a few options to make R produce more warnings so that it helps me know when something might cause an issue. It’s also a good place to set some defaults such as your favourite CRAN mirror so that R doesn’t need to ask you when you go to install packages.\n\nusethis::edit_r_profile()\n\n\n # load workflow helper packages if in interactive session\nif (interactive()) {\n  suppressMessages(require(devtools))\n  suppressMessages(require(usethis))\n  suppressMessages(require(testthat))\n}\n\n\n# set CRAN\noptions(repos = c(CRAN = \"https://cloud.r-project.org/\"))\n\n\n# warn on partial matches\noptions(\n  warnPartialMatchArgs = TRUE,\n  warnPartialMatchDollar = TRUE,\n  warnPartialMatchAttr = TRUE\n)\n\n# fancy quotes are annoying and lead to\n# 'copy + paste' bugs / frustrations\noptions(useFancyQuotes = FALSE)\n\nDon’t put analysis modifying options into your .Rprofile e.g. automatic loading of tidyverse. It will make the code you write less reproducible because it will start depending on these hidden settings, and it can make debugging harder.\n\n\n\n\nThe keyboard shortcut to rule them all: Alt + Shift + K\nOther useful shortcuts\n\n\n\nKeys\nproduces\n\n\n\n\nCtrl + Shift + M\n%&gt;%\n\n\nAlt + -\n&lt;-\n\n\nCtrl + Shift + K\nknits Rmd\n\n\nCtrl + Shift + F10\nRestart R\n\n\nCtrl + Alt + I\nInsert code chunk\n\n\nCtrl + Shift + S\nSource active file\n\n\nCtrl + .\nGo to file/function\n\n\n\nMake your own…\nTools -&gt; Modify Keyboard Shortcuts",
    "crumbs": [
      "Programming",
      "R Configuration"
    ]
  },
  {
    "objectID": "03-programming/03-env.html#configuration",
    "href": "03-programming/03-env.html#configuration",
    "title": "R Configuration",
    "section": "",
    "text": "As part setting R up to work best for us, we’re also wanting to make things easier on ourselves to that we can be more productive during the “do stuff” stage.\nThere is a hidden file called .Rprofile which is loaded as R launches and is a place where you can place customisations of options to make your R life easier. For instance I have mine set to automatically load workflow helper packages such as {usethis} {testthat} and {devtools}. And set a few options to make R produce more warnings so that it helps me know when something might cause an issue. It’s also a good place to set some defaults such as your favourite CRAN mirror so that R doesn’t need to ask you when you go to install packages.\n\nusethis::edit_r_profile()\n\n\n # load workflow helper packages if in interactive session\nif (interactive()) {\n  suppressMessages(require(devtools))\n  suppressMessages(require(usethis))\n  suppressMessages(require(testthat))\n}\n\n\n# set CRAN\noptions(repos = c(CRAN = \"https://cloud.r-project.org/\"))\n\n\n# warn on partial matches\noptions(\n  warnPartialMatchArgs = TRUE,\n  warnPartialMatchDollar = TRUE,\n  warnPartialMatchAttr = TRUE\n)\n\n# fancy quotes are annoying and lead to\n# 'copy + paste' bugs / frustrations\noptions(useFancyQuotes = FALSE)\n\nDon’t put analysis modifying options into your .Rprofile e.g. automatic loading of tidyverse. It will make the code you write less reproducible because it will start depending on these hidden settings, and it can make debugging harder.\n\n\n\n\nThe keyboard shortcut to rule them all: Alt + Shift + K\nOther useful shortcuts\n\n\n\nKeys\nproduces\n\n\n\n\nCtrl + Shift + M\n%&gt;%\n\n\nAlt + -\n&lt;-\n\n\nCtrl + Shift + K\nknits Rmd\n\n\nCtrl + Shift + F10\nRestart R\n\n\nCtrl + Alt + I\nInsert code chunk\n\n\nCtrl + Shift + S\nSource active file\n\n\nCtrl + .\nGo to file/function\n\n\n\nMake your own…\nTools -&gt; Modify Keyboard Shortcuts",
    "crumbs": [
      "Programming",
      "R Configuration"
    ]
  },
  {
    "objectID": "01-plotting/01-plotting.html",
    "href": "01-plotting/01-plotting.html",
    "title": "Plot Customisation",
    "section": "",
    "text": "Resources:",
    "crumbs": [
      "Plotting",
      "Plot Customisation"
    ]
  },
  {
    "objectID": "01-plotting/01-plotting.html#setup",
    "href": "01-plotting/01-plotting.html#setup",
    "title": "Plot Customisation",
    "section": "Setup",
    "text": "Setup\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\n# brings 'penguins' dataset into name space\nattach(penguins)\n# brings 'penguins_raw' dataset into name space\nattach(penguins_raw)\n\nThe base plot we’ll use to look at customisations\n\npenguin_plot &lt;- ggplot(\n  data = penguins,\n  mapping = aes(x = body_mass_g,\n                y = flipper_length_mm,\n                colour = island)\n) \n\npenguin_plot &lt;- penguin_plot +\n  geom_point()\n\npenguin_plot\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).",
    "crumbs": [
      "Plotting",
      "Plot Customisation"
    ]
  },
  {
    "objectID": "01-plotting/01-plotting.html#theming-and-labels",
    "href": "01-plotting/01-plotting.html#theming-and-labels",
    "title": "Plot Customisation",
    "section": "Theming and Labels",
    "text": "Theming and Labels\n\nlabs() can be used to alter the labels such as title, subtitle, x, and y.\ntheme() is used to alther elements of the theme\n\n\npenguin_plot &lt;- penguin_plot +\n  labs(x = \"Body Mass (g)\",\n       y = \"Flipper Lenght (mm)\",\n       title = \"Body Mass vs Flipper Length\") \n\npenguin_plot +\n  theme(panel.grid.minor = element_blank())\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nOr you can apply how pre-defined themes e.g. `theme_bw()\n\npenguin_plot +\n  theme_bw()\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).",
    "crumbs": [
      "Plotting",
      "Plot Customisation"
    ]
  },
  {
    "objectID": "01-plotting/01-plotting.html#customising-plots",
    "href": "01-plotting/01-plotting.html#customising-plots",
    "title": "Plot Customisation",
    "section": "Customising Plots",
    "text": "Customising Plots\n\nLegend customisation\nOften you will want to customise the colours used in the legend or the name of it\nMany generator functions exist and these differ by the scale type, but for manual specification scale_&lt;type&gt;_manual is the generic function, where &lt;type&gt; corresponds to the property used in aes.\n\npenguin_plot +\n  scale_colour_manual(name = \"Island\",\n    values = c(Biscoe = \"purple\", Dream = \"brown\", Torgersen = \"yellow\")\n  )\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\n\nggplot(penguins, aes(x = body_mass_g, y = flipper_length_mm, colour = species)) +\n  geom_point() +\n  scale_colour_manual(\n    name = \"Penguin species\",\n    values = c(Adelie = \"#1b9e77\", Chinstrap = \"#d95f02\", Gentoo = \"#7570b3\"),\n    labels = c(Adelie = \"Adelie (Aptenodytes)\", Chinstrap = \"Chinstrap (Pygoscelis)\", Gentoo = \"Gentoo (Pygoscelis)\")\n  ) +\n  guides(colour = guide_legend(title.position = \"top\", title.hjust = 0.5, nrow = 1)) +\n  theme(legend.position = \"top\")\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\n\n# increase point size in legend only (penguins)\nggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, colour = species)) +\n  geom_point(size = 2, na.rm = TRUE) +\n  guides(colour = guide_legend(override.aes = list(size = 6))) +\n  theme_minimal()\n\n\n\n\n\n\n\n# increase line thickness in legend only (penguins summarized by year)\ndf_line &lt;- penguins %&gt;%\n  filter(!is.na(species), !is.na(year), !is.na(body_mass_g)) %&gt;%\n  group_by(species, year) %&gt;%\n  summarise(mean_body_mass = mean(body_mass_g, na.rm = TRUE), .groups = \"drop\")\n\nggplot(df_line, aes(x = year, y = mean_body_mass, colour = species, group = species)) +\n  geom_line(linewidth = 0.7) +\n  geom_point(size = 1) +\n  guides(colour = guide_legend(override.aes = list(size = 3))) +\n  theme_minimal()",
    "crumbs": [
      "Plotting",
      "Plot Customisation"
    ]
  },
  {
    "objectID": "01-plotting/01-plotting.html#exercises",
    "href": "01-plotting/01-plotting.html#exercises",
    "title": "Plot Customisation",
    "section": "Exercises",
    "text": "Exercises\nExercise 1 — Scatter plot & legend styling Task: Create a scatter plot of body_mass_g (x) vs flipper_length_mm (y), colour points by species, add a title and axis labels, apply theme_bw(), set a manual colour scale (use three hex colours), and move the legend to the top with a single-row layout. Success criteria: plot shows colored points by species, custom colours used, title & axis labels present, legend at top in one row. Hint / starter code:\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\nggplot(penguins, aes(x = body_mass_g, y = flipper_length_mm, colour = species)) +\n  geom_point(na.rm = TRUE) +\n  labs(title = \"Body mass vs Flipper length\", x = \"Body mass (g)\", y = \"Flipper length (mm)\") +\n  scale_colour_manual(values = c(Adelie = \"#1b9e77\", Chinstrap = \"#d95f02\", Gentoo = \"#7570b3\")) +\n  guides(colour = guide_legend(nrow = 1, title.position = \"top\", title.hjust = 0.5)) +\n  theme_bw() +\n  theme(legend.position = \"top\")\n\nExercise 2 — Aggregation + line plot with legend overrides Task: Compute mean body mass per species per year, plot it as a line chart with points (one line per species), and make the legend show thicker lines than plotted in the panel (use guides override.aes). Success criteria: time series lines with points for each species, legend shows thicker line samples than panel lines. Hint / starter code:\n\ndf_line &lt;- penguins %&gt;%\n  filter(!is.na(species), !is.na(year), !is.na(body_mass_g)) %&gt;%\n  group_by(species, year) %&gt;%\n  summarise(mean_body_mass = mean(body_mass_g, na.rm = TRUE), .groups = \"drop\")\n\nggplot(df_line, aes(x = year, y = mean_body_mass, colour = species, group = species)) +\n  geom_line(linewidth = 0.6) +\n  geom_point(size = 1.5) +\n  guides(colour = guide_legend(override.aes = list(linewidth = 2, size = 4))) +\n  theme_minimal()\n\nExercise 3 — Facets, handling missing values, and saving output Task: Make a scatter plot of bill_length_mm vs bill_depth_mm, colour by sex, facet by island, remove rows with missing bill measurements before plotting, set axis limits to focus on typical ranges, and save the plot to “plots/bill_scatter.png” at 300 dpi. Success criteria: facets by island created, missing rows removed, axis limits set, plot saved to disk. Hint / starter code:\n\ndir.create(\"plots\", showWarnings = FALSE)\n\npenguins %&gt;%\n  drop_na(bill_length_mm, bill_depth_mm, sex) %&gt;%\n  ggplot(aes(x = bill_length_mm, y = bill_depth_mm, colour = sex)) +\n  geom_point(na.rm = TRUE) +\n  facet_wrap(~ island) +\n  xlim(30, 60) + ylim(10, 22) +\n  theme_classic() -&gt;\n  p\n\nggsave(\"plots/bill_scatter.png\", p, dpi = 300, width = 8, height = 5)",
    "crumbs": [
      "Plotting",
      "Plot Customisation"
    ]
  },
  {
    "objectID": "01-plotting/01-plotting.html#possible-solutions",
    "href": "01-plotting/01-plotting.html#possible-solutions",
    "title": "Plot Customisation",
    "section": "Possible solutions",
    "text": "Possible solutions\n\n# -------------------------\n# Possible solutions\n# -------------------------\n\n# Exercise 1 — Scatter plot & legend styling\nlibrary(ggplot2)\nex1_df &lt;- penguins %&gt;% drop_na(body_mass_g, flipper_length_mm, species)\n\nggplot(ex1_df, aes(x = body_mass_g, y = flipper_length_mm, colour = species)) +\n  geom_point(na.rm = TRUE) +\n  labs(\n    title = \"Body mass vs Flipper length\",\n    x = \"Body mass (g)\",\n    y = \"Flipper length (mm)\",\n    colour = \"Species\"\n  ) +\n  scale_colour_manual(\n    values = c(Adelie = \"#1b9e77\", Chinstrap = \"#d95f02\", Gentoo = \"#7570b3\")\n  ) +\n  guides(colour = guide_legend(nrow = 1, title.position = \"top\", title.hjust = 0.5)) +\n  theme_bw() +\n  theme(legend.position = \"top\")\n\n\n\n\n\n\n\n# Exercise 2 — Aggregation + line plot with legend overrides\ndf_line &lt;- penguins %&gt;%\n  filter(!is.na(species), !is.na(year), !is.na(body_mass_g)) %&gt;%\n  group_by(species, year) %&gt;%\n  summarise(mean_body_mass = mean(body_mass_g, na.rm = TRUE), .groups = \"drop\")\n\nggplot(df_line, aes(x = year, y = mean_body_mass, colour = species, group = species)) +\n  geom_line(linewidth = 0.6, na.rm = TRUE) +\n  geom_point(size = 1.5, na.rm = TRUE) +\n  labs(title = \"Mean body mass by species over years\", x = \"Year\", y = \"Mean body mass (g)\") +\n  guides(colour = guide_legend(override.aes = list(linewidth = 2, size = 4))) +\n  theme_minimal()\n\n\n\n\n\n\n\n# Exercise 3 — Facets, handling missing values, and saving output\ndir.create(\"plots\", showWarnings = FALSE)\n\nex3_df &lt;- penguins %&gt;% drop_na(bill_length_mm, bill_depth_mm, sex, island)\n\np &lt;- ggplot(ex3_df, aes(x = bill_length_mm, y = bill_depth_mm, colour = sex)) +\n  geom_point(na.rm = TRUE) +\n  facet_wrap(~ island) +\n  labs(title = \"Bill length vs Bill depth by island\", x = \"Bill length (mm)\", y = \"Bill depth (mm)\") +\n  coord_cartesian(xlim = c(30, 60), ylim = c(10, 22)) +  # focus on typical ranges without dropping data\n  theme_classic()\n\n#ggsave(\"plots/bill_scatter.png\", p, dpi = 300, width = 8, height = 5)",
    "crumbs": [
      "Plotting",
      "Plot Customisation"
    ]
  },
  {
    "objectID": "02-wrangling-overview.html",
    "href": "02-wrangling-overview.html",
    "title": "Data Wrangling",
    "section": "",
    "text": "In wrangling we’re looking mostly at functions that come from {dplyr}",
    "crumbs": [
      "Data Manipulation"
    ]
  },
  {
    "objectID": "02-wrangling-overview.html#dplyr-refresher-with-palmerpenguins",
    "href": "02-wrangling-overview.html#dplyr-refresher-with-palmerpenguins",
    "title": "Data Wrangling",
    "section": "dplyr refresher with palmerpenguins",
    "text": "dplyr refresher with palmerpenguins\nThis short refresher demonstrates select, filter, mutate, group_by, and summarise using the palmerpenguins dataset.\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\n# minimal clean dataset for examples\npenguins_clean &lt;- penguins %&gt;%\n  select(species, island, bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g, sex) %&gt;%\n  drop_na()\n\nselect — keep specific columns\n\npenguins_clean %&gt;%\n  select(species, island, body_mass_g) %&gt;%\n  slice_head(n = 6)\n\n# A tibble: 6 × 3\n  species island    body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;           &lt;int&gt;\n1 Adelie  Torgersen        3750\n2 Adelie  Torgersen        3800\n3 Adelie  Torgersen        3250\n4 Adelie  Torgersen        3450\n5 Adelie  Torgersen        3650\n6 Adelie  Torgersen        3625\n\n\nfilter — keep rows matching conditions\n\n# filter by species and body mass &gt; 4000 g\npenguins_clean %&gt;%\n  filter(species == \"Adelie\", body_mass_g &gt; 4000) %&gt;%\n  slice_head(n = 6)\n\n# A tibble: 6 × 7\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Torgersen           39.2          19.6               195        4675\n2 Adelie  Torgersen           34.6          21.1               198        4400\n3 Adelie  Torgersen           42.5          20.7               197        4500\n4 Adelie  Torgersen           46            21.5               194        4200\n5 Adelie  Dream               39.2          21.1               196        4150\n6 Adelie  Dream               39.8          19.1               184        4650\n# ℹ 1 more variable: sex &lt;fct&gt;\n\n\nmutate — add or transform columns\n\n# add body mass in kg and bill ratio\npenguins_clean %&gt;%\n  mutate(\n    body_mass_kg = body_mass_g / 1000,\n    bill_ratio = bill_length_mm / bill_depth_mm\n  ) %&gt;%\n  slice_head(n = 6)\n\n# A tibble: 6 × 9\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           36.7          19.3               193        3450\n5 Adelie  Torgersen           39.3          20.6               190        3650\n6 Adelie  Torgersen           38.9          17.8               181        3625\n# ℹ 3 more variables: sex &lt;fct&gt;, body_mass_kg &lt;dbl&gt;, bill_ratio &lt;dbl&gt;\n\n\ngroup_by + summarise — aggregate by groups\n\n# mean body mass and median flipper length per species\npenguins_clean %&gt;%\n  group_by(species) %&gt;%\n  summarise(\n    n = n(),\n    mean_body_mass = mean(body_mass_g, na.rm = TRUE),\n    median_flipper = median(flipper_length_mm, na.rm = TRUE)\n  ) %&gt;%\n  arrange(desc(mean_body_mass))\n\n# A tibble: 3 × 4\n  species       n mean_body_mass median_flipper\n  &lt;fct&gt;     &lt;int&gt;          &lt;dbl&gt;          &lt;dbl&gt;\n1 Gentoo      119          5092.            216\n2 Chinstrap    68          3733.            196\n3 Adelie      146          3706.            190",
    "crumbs": [
      "Data Manipulation"
    ]
  },
  {
    "objectID": "02-wrangling/01-wrangle.html",
    "href": "02-wrangling/01-wrangle.html",
    "title": "Extra wrangling data with dplyr",
    "section": "",
    "text": "library(tidyverse)\nlibrary(palmerpenguins)\n\n# minimal clean dataset for examples\npenguins_clean &lt;- penguins %&gt;%\n  select(species, island, bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g, sex) %&gt;%\n  drop_na()",
    "crumbs": [
      "Data Manipulation",
      "Extra wrangling data with dplyr"
    ]
  },
  {
    "objectID": "02-wrangling/01-wrangle.html#using-across-and-where",
    "href": "02-wrangling/01-wrangle.html#using-across-and-where",
    "title": "Extra wrangling data with dplyr",
    "section": "Using across() and where()",
    "text": "Using across() and where()\nUse across() to apply the same transformation or summary to multiple columns; use where() to select columns by predicate (e.g., is.numeric, is.character).\n\n# 1) mutate with across + where: convert numeric measurements to centimeters\npenguins_clean %&gt;%\n  mutate(across(where(is.numeric), .fns = \\(x){x / 10}, .names = \"{.col}_cm\")) %&gt;%\n  select(species, ends_with(\"_cm\")) %&gt;%\n  slice_head(n = 6)\n\n# A tibble: 6 × 5\n  species bill_length_mm_cm bill_depth_mm_cm flipper_length_mm_cm body_mass_g_cm\n  &lt;fct&gt;               &lt;dbl&gt;            &lt;dbl&gt;                &lt;dbl&gt;          &lt;dbl&gt;\n1 Adelie               3.91             1.87                 18.1           375 \n2 Adelie               3.95             1.74                 18.6           380 \n3 Adelie               4.03             1.8                  19.5           325 \n4 Adelie               3.67             1.93                 19.3           345 \n5 Adelie               3.93             2.06                 19             365 \n6 Adelie               3.89             1.78                 18.1           362.\n\n\n\n# 2) mutate with across on character columns: normalize text\npenguins_clean %&gt;%\n  mutate(across(where(is.character), ~ str_to_title(.))) %&gt;%\n  slice_head(n = 6)\n\n# A tibble: 6 × 7\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           36.7          19.3               193        3450\n5 Adelie  Torgersen           39.3          20.6               190        3650\n6 Adelie  Torgersen           38.9          17.8               181        3625\n# ℹ 1 more variable: sex &lt;fct&gt;\n\n\n\n# 3) summarise with across: compute mean and sd for all numeric columns per species\npenguins_clean %&gt;%\n  group_by(species) %&gt;%\n  summarise(across(where(is.numeric),\n                   list(mean = ~ mean(.x, na.rm = TRUE),\n                        sd   = ~ sd(.x, na.rm = TRUE)),\n                   .names = \"{.col}_{.fn}\"))\n\n# A tibble: 3 × 9\n  species   bill_length_mm_mean bill_length_mm_sd bill_depth_mm_mean\n  &lt;fct&gt;                   &lt;dbl&gt;             &lt;dbl&gt;              &lt;dbl&gt;\n1 Adelie                   38.8              2.66               18.3\n2 Chinstrap                48.8              3.34               18.4\n3 Gentoo                   47.6              3.11               15.0\n# ℹ 5 more variables: bill_depth_mm_sd &lt;dbl&gt;, flipper_length_mm_mean &lt;dbl&gt;,\n#   flipper_length_mm_sd &lt;dbl&gt;, body_mass_g_mean &lt;dbl&gt;, body_mass_g_sd &lt;dbl&gt;\n\n\n\n# 4) summarise with across + select helpers: mean of bill measurements\npenguins_clean %&gt;%\n  group_by(species) %&gt;%\n  summarise(across(starts_with(\"bill_\"), mean, na.rm = TRUE, .names = \"mean_{.col}\"))\n\nWarning: There was 1 warning in `summarise()`.\nℹ In argument: `across(starts_with(\"bill_\"), mean, na.rm = TRUE, .names =\n  \"mean_{.col}\")`.\nℹ In group 1: `species = Adelie`.\nCaused by warning:\n! The `...` argument of `across()` is deprecated as of dplyr 1.1.0.\nSupply arguments directly to `.fns` through an anonymous function instead.\n\n  # Previously\n  across(a:b, mean, na.rm = TRUE)\n\n  # Now\n  across(a:b, \\(x) mean(x, na.rm = TRUE))\n\n\n# A tibble: 3 × 3\n  species   mean_bill_length_mm mean_bill_depth_mm\n  &lt;fct&gt;                   &lt;dbl&gt;              &lt;dbl&gt;\n1 Adelie                   38.8               18.3\n2 Chinstrap                48.8               18.4\n3 Gentoo                   47.6               15.0",
    "crumbs": [
      "Data Manipulation",
      "Extra wrangling data with dplyr"
    ]
  },
  {
    "objectID": "02-wrangling/01-wrangle.html#names-examples",
    "href": "02-wrangling/01-wrangle.html#names-examples",
    "title": "Extra wrangling data with dplyr",
    "section": ".names examples",
    "text": ".names examples",
    "crumbs": [
      "Data Manipulation",
      "Extra wrangling data with dplyr"
    ]
  }
]